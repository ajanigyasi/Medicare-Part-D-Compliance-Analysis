Sys.getenv("PATH")
Sys.which("pdflatex")
install.packages("Rtools")
install.Rtools()
library(installr)
version()
Version()
install.packages("rmarkdown")
Sys.getenv("pdflatex")
Sys.which("pdflatex")
find.package("devtools")
install.packages("devtools")
library(devtools)
find_rtools()
rmarkdown::render('relevelRegression_models.Rmd',
output_format=pdf_document(latex_engine='xelatex')
)
library(devtools)
(devtools::install_github("rstudio/rmarkdown"))
system("pdflatex --version")
library(datasets)
data(mtcars)
head(mtcars)
(3(0.01)^3 + 2) - (3(0.99)^3 +2)
(3*(0.01)^3 + 2) - (3*(0.99)^3 +2)
-2.910894/(2*0.01)
2*0.01
-2.910894/0.02
(3*(0.01)^4 + 4) - (3*(0.99)^4 +4)
(3*(0.01^4) + 4) - (3*(0.99^4) +4)
((3*(0.01^4) + 4) - (3*(0.99^4) +4))/0.02
/12
-144.0894/12
((3*(0.01^4) + 4) - ((30.99)^4) +4))/0.02
((3*0.01)^4 + 4) - ((3*0.99)^4 +4)/0.02
-4086.414/12
(3*(0.01)^4 + 4) - (3*(0.99)^4 +4)
3*0.01
0.03^4
0.00000081+4
81.80827681-4.000001
77.80828/0.02
(3*(0.01)^4 +4)-(3*(0.99)^4 +4)/2*(0.01)
((3*(0.01)^4 +4)-(3*(0.99)^4 +4))/2*(0.01)
12*0.01440894
(3*(0.01)^4 +4)-(3*(0.99)^4 +4)/(2*(0.01))
(3*(0.01)^4 +4)-(3*(0.99)^4 +4)
-2.881788/2*(0.01)
2*0.01
-2.881788/0.02
144.0894/12
(3*(0.01)^4 +4)-(3*(0.99)^4 +4)/2*(0.01)
3.965591/12
12/3.965591
(3*(0.01)^4 +4)-(3*(0.99)^4 +4)/2*(0.01)
((3*(0.01)^4 +4)-(3*(0.99)^4 +4))/2*(0.01)
((3*(0.01)^4 +4)-(3*(0.99)^4 +4))/(2*(0.01))
3*0.01^4 +4-3*0.99^4 +4/2*0.01
12.0012*0.02
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
```
```{r}
```
```{r}
```
```{r}
```
```{r}
```
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
library(caret)
install.packages("caret")
install.packages("AppliedPredictiveModeling")
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
ss <- training[,grep('^IL', x = names(training) )]
preProc <- preProcess(ss, method='pca', thresh=0.8,
outcome=training$diagnosis)
preProc$rotation
library(quantmod)
library(nnet)
library(caret)
library(plyr)
births <- scan("http://robjhyndman.com/tsdldata/data/nybirths.dat")
birthstimeseries <- ts(births, frequency=12, start=c(1946,1))
class(bibbirthstimeseries)
head(birthstimeseries)
class(bibbirthstimeseries)
birthstimeseries
plot(birthstimeseries)
plot(birthstimeseries, type = "b")
View(birthstimeseries)
dim(birthstimeseries)
library(forecast)
library(lmtest)
library(caret)
wi<-read.csv('http://www.quandl.com/api/v1/datasets/FRED/WIUR.csv?&auth_token=gigXwpxd6Ex91cjgz1B7&trim_start=1976-01-01&trim_end=2013-04-01&sort_order=desc', colClasses=c('Date'='Date'))
View(wi)
colnames(wi)<-c('date', 'rate')
wi$date<-as.Date(wi$date)
View(wi)
wi.b<-wi[1:436,]
wi.p<-wi[437:448,]
View(wi.b)
View(wi.p)
wi.ts<-ts(wi.b$rate, start=c(1976, 1), frequency=12)
wi.p.ts<-ts(wi.p$rate, start=c(2012, 5), frequency=12)
plot(wi.ts)
plot(wi.ts)
plot(wi.p.ts)
View(wi.ts)
View(wi.p.ts)
mean<-meanf(wi.ts, 12)
naive<-rwf(wi.ts, 12)
s.naive<-snaive(wi.ts, 12)
drift<-rwf(wi.ts, 12, drift=T)
m1<-tslm(wi.ts~trend)
m2<-tslm(wi.ts~trend+season)
res1 <- residuals(m1)
par(mfrow=c(1,2))
plot(res1, ylab="Residuals",xlab="Year")
Acf(res1, main="ACF of residuals")
res2 <- residuals(m2)
par(mfrow=c(1,2))
plot(res2, ylab="Residuals",xlab="Year")
Acf(res2, main="ACF of residuals")
par(mfrow=c(1,1))
library(frbs)
data(frbsData)
data.train <- frbsData$GasFurnance.dt[1 : 204, ]
data.fit <- data.train[, 1 : 2]
data.tst <- frbsData$GasFurnance.dt[205 : 292, 1 : 2]
real.val <- matrix(frbsData$GasFurnance.dt[205 : 292, 3], ncol = 1)
range.data<-matrix(c(-2.716, 2.834, 45.6, 60.5, 45.6, 60.5), nrow=2)
View(data.train)
View(range.data)
data(iris)
set.seed(2)
irisShuffled <- iris[sample(nrow(iris)),]
irisShuffled[,5] <- unclass(irisShuffled[,5])
tra.iris <- irisShuffled[1:105,]
tst.iris <- irisShuffled[106:nrow(irisShuffled),1:4]
real.iris <- matrix(irisShuffled[106:nrow(irisShuffled),5], ncol = 1)
range.data <- matrix(c(4.3, 7.9, 2.0, 4.4, 1.0, 6.9, 0.1, 2.5), nrow=2)
method.type <- "GFS.GCCL"
control <- list(popu.size = 30, num.class = 3, num.labels = 3, persen_cross = 0.9,
max.gen = 200, persen_mutant = 0.3,
name="sim-0")
data(fbrs)
library(frbs)
install.packages("xlsx")
install.packages("RCurl")
R
library(RCurl)
library(xlsx)
library(rJava)
library("rJava", lib.loc="~/R/win-library/3.3")
library("xlsx", lib.loc="~/R/win-library/3.3")
library("xlsx", lib.loc="C:/Users/sanbeley/Documents/R/win-library/3.3")
install.packages("xlsx")
library(xlsx)
install.packages("rJava")
library(rJava)
library(xlsx)
install.packages('rJava', .libPaths()[1], 'http://www.rforge.net/')
library(rJava)
if (Sys.getenv("JAVA_HOME")!="")
Sys.setenv(JAVA_HOME="")
library(rJava)
library(xlsx)
library(rJava)
install.packages("rJava")
library(rJava)
Sys.setenv(JAVA_HOME='C:\\Program Files\\Java\\sanbeley')
library(rJava)
Sys.setenv(JAVA_HOME='C:/Users/sanbeley/Documents/R/win-library/3.3/rJava/libs/x64/')
library(rJava)
library(xlsx)
install.packages("rJava")
library(rJava)
Sys.setenv(JAVA_HOME='C:\\Program Files\\Java\\jre')
library(rJava)
Sys.setenv(JAVA_HOME='C:\\Program Files\\Java\\jre7')
library(rJava)
library(rJava)
library(frbs)
library(RCurl)
x <- getURL("https://raw.githubusercontent.com/codenotfound/fuzzy_social_forecast/master/shinyFuzzyForecast/data/spb_population.csv")
tmp <- read.csv(text = x, sep = ";")
t <- tmp$population[3:31]
tminus1 <- tmp$population[2:30]
tminus2 <- tmp$population[1:29]
spb_population <- data.frame(tminus2, tminus1 , t)
1113-18
1113-12
1113-6
varinp.mf <- matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA,
2, 0, 35, 75, NA, 3, 35, 75, 100, NA,
2, 0, 20, 40, NA, 1, 20, 50, 80, NA, 3, 60, 80, 100, NA,
2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
nrow = 5, byrow = FALSE)
## Define number of fuzzy terms of input variables.
## Suppose, we have 3, 2, 3, and 3 numbers of fuzzy terms
## for first, second, third and fourth variables, respectively.
num.fvalinput <- matrix(c(3, 2, 3, 3), nrow=1)
## Give the names of the fuzzy terms of each input variable.
## It should be noted that the names of the fuzzy terms must be unique,
## so we put a number for making it unique.
varinput.1 <- c("a1", "a2", "a3")
varinput.2 <- c("b1", "b2")
varinput.3 <- c("c1", "c2", "c3")
varinput.4 <- c("d1", "d2", "d3")
names.varinput <- c(varinput.1, varinput.2, varinput.3, varinput.4)
## Set interval of data.
range.data <- matrix(c(0,100, 0, 100, 0, 100, 0, 100, 0, 100), nrow=2)
## Set weighted average method to be used as defuzzification method.
type.defuz <- "WAM"
## We are using standard t-norm and s-norm.
type.tnorm <- "MIN"
type.snorm <- "MAX"
type.implication.func <- "ZADEH"
## Give the name of simulation.
name <- "Sim-0"
## Provide new data for testing.
newdata<- matrix(c(25, 40, 35, 15, 45, 75, 78, 70), nrow= 2, byrow = TRUE)
## the names of variables
colnames.var <- c("input1", "input2", "input3", "input4", "output1")
type.model <- "TSK"
## Define function of TSK
func.tsk<-matrix(c(1, 1, 5, 2, 1, 3, 1, 0.5, 0.1, 2, 1, 3, 2, 2, 2), nrow=3, byrow=TRUE)
## Define the fuzzy IF-THEN rules;
## For TSK model, it isn't necessary to put linguistic term in consequent parts.
## Make sure that each rule has a "->" sign.
rule <- matrix(c("very a1","and","b1","and","slghtly c1","and","d1","->",
"a2","and","extremely b2","and","c2","and","d2", "->",
"a3","and","b2","and","c2","and","dont_care", "->"),
nrow=3, byrow=TRUE)
## Generate a fuzzy model with frbs.gen.
## It should be noted that for TSK model, we do not need to input:
## num.fvaloutput, varout.mf, names.varoutput, type.defuz.
##
object <- frbs.gen(range.data, num.fvalinput, names.varinput, num.fvaloutput = NULL,
varout.mf = NULL, names.varoutput = NULL, rule,
varinp.mf, type.model, type.defuz = NULL, type.tnorm, type.snorm, func.tsk, colnames.var,
type.implication.func, name)
library(frbs)
object <- frbs.gen(range.data, num.fvalinput, names.varinput, num.fvaloutput = NULL,
varout.mf = NULL, names.varoutput = NULL, rule,
varinp.mf, type.model, type.defuz = NULL, type.tnorm, type.snorm, func.tsk, colnames.var,
type.implication.func, name)
View(varinp.mf)
View(object$varinp.mf)
class(names.varinput)
varinp.mf <- matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA,
2, 0, 35, 75, NA, 3, 35, 75, 100, NA,
2, 0, 20, 40, NA, 1, 20, 50, 80, NA, 3, 60, 80, 100, NA,
2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
nrow = 5, byrow = FALSE)
## Define number of fuzzy terms of input variables.
## Suppose, we have 3, 2, 3, and 3 numbers of fuzzy terms
## for first, second, third and fourth variables, respectively.
num.fvalinput <- matrix(c(3, 2, 3, 3), nrow=1)
## Give the names of the fuzzy terms of each input variable.
## It should be noted that the names of the fuzzy terms must be unique,
varinput.1 <- c("a1", "a2", "a3")
varinput.2 <- c("b1", "b2")
varinput.3 <- c("c1", "c2", "c3")
## so we put a number for making it unique.
varinput.4 <- c("d1", "d2", "d3")
## Set interval of data.
names.varinput <- c(varinput.1, varinput.2, varinput.3, varinput.4)
range.data <- matrix(c(0,100, 0, 100, 0, 100, 0, 100, 0, 100), nrow=2)
## Set weighted average method to be used as defuzzification method.
type.defuz <- "WAM"
## We are using standard t-norm and s-norm.
type.tnorm <- "MIN"
type.snorm <- "MAX"
type.implication.func <- "ZADEH"
## Give the name of simulation.
name <- "Sim-0"
## Provide new data for testing.
newdata<- matrix(c(25, 40, 35, 15, 45, 75, 78, 70), nrow= 2, byrow = TRUE)
## the names of variables
colnames.var <- c("input1", "input2", "input3", "input4", "output1")
#####################################################################
## 1b. Using Takagi Sugeno Kang (TSK) Model
#####################################################################
type.model <- "TSK"
## Define function of TSK
func.tsk<-matrix(c(1, 1, 5, 2, 1, 3, 1, 0.5, 0.1, 2, 1, 3, 2, 2, 2), nrow=3, byrow=TRUE)
## Define the fuzzy IF-THEN rules;
## For TSK model, it isn't necessary to put linguistic term in consequent parts.
## Make sure that each rule has a "->" sign.
rule <- matrix(c("very a1","and","b1","and","slghtly c1","and","d1","->",
"a2","and","extremely b2","and","c2","and","d2", "->",
"a3","and","b2","and","c2","and","dont_care", "->"),
nrow=3, byrow=TRUE)
## Generate a fuzzy model with frbs.gen.
## It should be noted that for TSK model, we do not need to input:
## num.fvaloutput, varout.mf, names.varoutput, type.defuz.
##
object <- frbs.gen(range.data, num.fvalinput, names.varinput, num.fvaloutput = NULL,
varout.mf = NULL, names.varoutput = NULL, rule,
varinp.mf, type.model, type.defuz = NULL, type.tnorm, type.snorm, func.tsk, colnames.var,
type.implication.func, name)
## We can plot the membership function
plotMF(object)
library(frbs)
View(varinp.mf)
object <- frbs.gen(range.data, num.fvalinput, names.varinput, num.fvaloutput = NULL,
varout.mf = NULL, names.varoutput = NULL, rule,
varinp.mf, type.model, type.defuz = NULL, type.tnorm, type.snorm, func.tsk, colnames.var,
type.implication.func, name)
plotMF(object)
View(newdata)
View(rule)
data("frbsData")
View(frbsData$MackeyGlass1000.dt)
data.train <- frbsData$MackeyGlass1000.dt[1: 500, ]
data.fit <- data.train[, 1 : 4]
data.tst <- frbsData$MackeyGlass1000.dt[501 : 1000, 1 : 4]
real.val <- matrix(frbsData$MackeyGlass1000.dt[501 : 1000, 5], ncol = 1)
range.data <- matrix(c(0.43462, 1.3105, 0.43462, 1.3105, 0.43462, 1.3105, 0.43462, 1.3105, 0.43462, 1.3105), nrow=2)
## Set the method and its parameters
method.type <- "ANFIS"
control <- list(num.labels = 5, max.iter = 50, step.size = 0.01, type.tnorm = "MIN", type.snorm = "MAX", type.implication.func = "ZADEH", name = "MG1000")
## Generate fuzzy model
object <- frbs.learn(data.train, range.data, method.type, control)
plotMF(object)
get_params <- function(l, r, shape = c("s", "z")) {
shape <- match.arg(shape)
if (shape == "s")
y <- c(0.01, 0.5, 0.99)
else
y <- c(0.99, 0.5, 0.01)
x <- c(l, (l + r)/2, r)
slope <- ifelse(shape == "s", 1/(r - l),  1/(r - l))
data <- list(x = x, y = y)
fitModel <- nls(y ~ a/(1 + exp(-b * (x - ((l + r)/2)))),
data, start = c(a = 1, b = slope),
algorithm = "port")
# get the coefficients using the coef function
params <- coef(fitModel)
params[2]
}
get_mid <- function(bounds, row) {
(bounds[row, 1] + bounds[row, 2])/2
}
var_bounds <- get_var_bounds()
cacheEnv <- new.env()
init_vars <- function(){
left_bounds <- c(3, 2, 0, 20, 25, 10, 20, 3, 4, 85, 90, 85, 90, -5, -5, 10, 15, 150, 0, 0, 5, 10)
right_bounds <- c(6, 4, 2, 45, 60, 40, 50, 5, 6, 100, 120, 100, 120, 5, 10, 20, 30, 200, 1, 1, 15, 25)
df <- data.frame(left_bounds, right_bounds, row.names = c("speed_high", "speed_low", "speed_zero", "HE_small",
"HE_large", "PD_short", "PD_long", "HDOP_good",
"HDOP_bad", "alpha_low", "alpha_high", "beta_low", "beta_high",
"delta_dist_neg", "delta_dist_pos",
"HI_small", "HI_large", "HI_180", "connectivity_direct",
"connectivity_indirect", "dist_err_small", "dist_err_large"))
df$ID <- 1:nrow(df)
df
}
assign("var_bounds", init_vars(), envir = cacheEnv)
get_var_bounds <- function() get("var_bounds", envir = cacheEnv)
var_bounds <- get_var_bounds()
m <- matrix(c(6, get_params(var_bounds[1, 1], var_bounds[1, 2], "s"), #speed_high
get_mid(var_bounds, 1), NA, NA,
6, get_params(var_bounds[2, 1], var_bounds[2, 2], "z"), #sped_low
get_mid(var_bounds, 2), NA, NA,
6, get_params(var_bounds[3, 1], var_bounds[3, 2], "z"), #speed_zero
get_mid(var_bounds, 3), NA, NA,
6, get_params(var_bounds[4, 1], var_bounds[4, 2], "z"), #HE_small
get_mid(var_bounds, 4), NA, NA,
6, get_params(var_bounds[5, 1], var_bounds[5, 2], "s"), #HE_large
get_mid(var_bounds, 5), NA, NA,
6, get_params(var_bounds[6, 1], var_bounds[6, 2], "z"), #PD_short
get_mid(var_bounds, 6), NA, NA,
6, get_params(var_bounds[7, 1], var_bounds[7, 2], "s"), #PD_long
get_mid(var_bounds, 7), NA, NA,
6, get_params(var_bounds[8, 1], var_bounds[8, 2], "z"), #HDOP_good
get_mid(var_bounds, 8), NA, NA,
6, get_params(var_bounds[9, 1], var_bounds[9, 2], "s"), #HDOP_bad
get_mid(var_bounds, 9), NA, NA),
nrow = 5, byrow = FALSE)
View(m)
colnames.var1 <- c("v", "HE", "PD", "HDOP", "output")
varinput.1 <- c("high", "low", "zero")
varinput.2 <- c("small", "large")
varinput.3 <- c("short", "long")
varinput.4 <- c("good", "bad")
names.varinput1 <- c(varinput.1, varinput.2, varinput.3, varinput.4)
range.data1 <- matrix(c(0, 50, 0, 360, 0, 60, 0, 20, 0, 100), nrow = 2)
# Define number of fuzzy terms of input variables.
num.fvalinput1 <- matrix(c(3, 2, 2, 2), nrow = 1)
# Set the name of the simulation
name1 <- "Sim-1"
r1 <- c("high","and","small","and","dont_care","and","dont_care", "->")
r2 <- c("high","and","large", "and", "dont_care", "and", "dont_care", "->")
r3 <- c("dont_care", "and", "dont_care", "and", "short","and","good", "->")
r4 <- c("dont_care", "and", "dont_care", "and", "long","and","good", "->")
r5 <- c("dont_care", "and", "small","and","short", "and", "dont_care", "->")
r6 <- c("dont_care", "and", "large","and","long", "and", "dont_care", "->")
rule1 <- list(r1, r2, r3, r4, r5, r6)
rule1 <- do.call(rbind, rule1)
View(rule1)
func.tsk1 <- matrix(c(50, 10, 50, 10, 100, 10), nrow = 6, byrow = TRUE)
assign("varinp.mf1", m, envir = cacheEnv)
varinp.mf1 <- get("varinp.mf1", envir = cacheEnv)
fis1 <- frbs.gen(range.data1, num.fvalinput1, names.varinput1, num.fvaloutput = NULL,
varout.mf = NULL, names.varoutput = NULL, rule1,
varinp.mf1, type.model, type.defuz = NULL, type.tnorm, type.snorm, func.tsk1, colnames.var1,
type.implication.func, name1)
library(frbs)
fis1 <- frbs.gen(range.data1, num.fvalinput1, names.varinput1, num.fvaloutput = NULL,
varout.mf = NULL, names.varoutput = NULL, rule1,
varinp.mf1, type.model, type.defuz = NULL, type.tnorm, type.snorm, func.tsk1, colnames.var1,
type.implication.func, name1)
type.model <- "TSK"
type.tnorm <- "MIN"
type.snorm <- "MAX"
type.implication.func <- "MIN"
fis1 <- frbs.gen(range.data1, num.fvalinput1, names.varinput1, num.fvaloutput = NULL,
varout.mf = NULL, names.varoutput = NULL, rule1,
varinp.mf1, type.model, type.defuz = NULL, type.tnorm, type.snorm, func.tsk1, colnames.var1,
type.implication.func, name1)
plotMF
plotMF(fis1)
View(var_bounds)
z <- seq(0,1)
z
z <- seq(0,1, length.out = 11)
z
z <- seq(0,20, length.out = 11)
z
z <- seq(0,153, length.out = 11)
z
suppressPackageStartupMessages(library(googleVis)) #so a long startup message does not appear
library(googleVis)
require(RCurl)
diseaseData <- read.csv(text = getURL("https://github.com/dariodata/medicare-drug-cost/blob/master/data/drug-disease_keys.csv"))
View(diseaseData)
class(diseaseData)
diseaseData <- read.csv(text = getURL("https://github.com/dariodata/medicare-drug-cost/raw/master/data/drug-disease_keys.csv"))
View(diseaseData)
diseaseData <- read.csv(text = getURL("https://raw.githubusercontent.com/dariodata/medicare-drug-cost/master/data/drug-disease_keys.csv"))
View(diseaseData)
drugData <- read.csv(text = getURL("https://githubusercontent.com/dariodata/medicare-drug-cost/master/data/medicare_data_disease.csv"))
drugData <- read.csv(text = getURL("https://githubusercontent.com/dariodata/medicare-drug-cost/master/data/medicare_data_disease.csv"))
require(RCurl)
drugData <- read.csv(text = getURL("https://githubusercontent.com/dariodata/medicare-drug-cost/master/data/medicare_data_disease.csv"))
library(devtools)
library(httr)
install_github("cranvas")
drugData <- read.csv(text = getURL("https://githubusercontent.com/dariodata/medicare-drug-cost/master/data/medicare_data_disease.csv"))
drugData <- read.csv(text = getURL("https://raw.githubusercontent.com/dariodata/medicare-drug-cost/master/data/medicare_data_disease.csv"))
View(drugData)
library("dplyr")
install.packages("dplyr")
library("dplyr")
dim(drugData)
indData <- c(drugData$Total.Spending, drugData$Indication)
indData <- as.data.frame(c(drugData$Total.Spending, drugData$Indication))
View(indData)
indData <- drugData[,c(5,16)]
View(indData)
indSpend <- drugData[,c(5,16)]
drugSpend <- drugData[,c(5, 15)]
View(drugSpend)
rankData <- data.frame(cbind(rank(indSpend$Total.Spending, ties.method = "average"),
rank(drugSpend$Total.Spending, ties.method = "average")))
colnames(rankData) <- c("Disease", "Drug")
View(rankData)
View(rankData)
indSpend <- order(indSpend$Total.Spending, decreasing = TRUE)
indSpend <- inSpend[order(indSpend$Total.Spending, decreasing = TRUE),]
indSpend <- indSpend[order(indSpend$Total.Spending, decreasing = TRUE),]
indSpend <- drugData[, c(5,16)]
indSpend <- indSpend[order(indSpend$Total.Spending, decreasing = TRUE),]
View(indSpend)
indSpend <- drugData[, c(5,16)]
indSpendOrder <- indSpend[order(indSpend$Total.Spending, decreasing = TRUE),]
View(indSpendOrder)
indSpend <- drugData[, c(5,14,16)]
drugSpend <- drugData[,c(5,14,15)]
indSpendOrder <- indSpend[order(indSpend$Total.Spending, decreasing = TRUE),]
View(indSpendOrder)
drugSpendOrder <- drugSpend[order(drugSpend$Total.Spending, decreasing = TRUE),]
View(drugSpendOrder)
install.packages("ggplot2")
setwd("C:/")
setwd("E:/CDC/Medicare Part D Compliance Analysis")
setwd("C:/Coursera/Medicare Part D Compliance Analysis")
